# Agent2Agent (A2A) Protocol Documentation

## Table of Contents
- [Overview](#overview)
- [Key Concepts](#key-concepts)
- [Protocol Specification](#protocol-specification)
- [Python SDK Guide](#python-sdk-guide)
- [CLI Implementation](#cli-implementation)
- [Implementation Patterns](#implementation-patterns)
- [Quick Start Examples](#quick-start-examples)
- [Security Considerations](#security-considerations)
- [Dependencies & Setup](#dependencies--setup)

## Overview

### What is A2A?

The **Agent2Agent (A2A) Protocol** is an open standard designed to enable seamless communication and collaboration between AI agents built by different teams, using different technologies, and owned by different organizations. It solves the fundamental challenge of agent interoperability in the rapidly evolving AI landscape.

**Key Benefits:**
- **Interoperability**: Connect agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions)
- **Complex Workflows**: Enable agents to delegate sub-tasks, exchange information, and coordinate actions
- **Secure & Opaque**: Agents interact without needing to share internal memory, tools, or proprietary logic
- **Enterprise Ready**: Built-in support for authentication, authorization, and security

### A2A vs MCP

A2A and the [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) are complementary standards:

- **MCP (Model Context Protocol)**: Connects agents to **tools, APIs, and resources** with structured inputs/outputs
- **A2A (Agent2Agent Protocol)**: Facilitates **dynamic, multimodal communication between different agents** as peers

## Key Concepts

### Core Actors

- **User**: The end user (human or automated service) who initiates requests
- **A2A Client (Client Agent)**: An application or agent that acts on behalf of the user to request actions from remote agents
- **A2A Server (Remote Agent)**: An AI agent that exposes an HTTP endpoint implementing the A2A protocol

### Fundamental Communication Elements

#### Agent Card
A JSON metadata document that describes an A2A Server, typically discoverable at `/.well-known/agent.json`. Contains:
- Identity (name, description, version)
- Service endpoint URL and capabilities
- Supported skills and input/output modalities
- Authentication requirements
- Security schemes

#### Task
A stateful unit of work managed by the A2A Server. Tasks progress through a defined lifecycle:
- `submitted`: Task received and acknowledged
- `working`: Task is actively being processed
- `input-required`: Agent needs additional input from client
- `completed`: Task finished successfully
- `canceled`: Task was canceled
- `failed`: Task terminated due to error
- `rejected`: Task rejected by remote agent
- `auth-required`: Additional authentication needed

#### Message
A single communication turn between client and agent with:
- `role`: Either "user" (client-sent) or "agent" (server-sent)
- `parts`: Array of content parts (text, file, or data)
- `messageId`: Unique identifier set by sender
- Optional context and task association

#### Part
The fundamental content unit within Messages or Artifacts:
- **TextPart**: Plain textual content
- **FilePart**: File content (base64 bytes or URI reference)
- **DataPart**: Structured JSON data for forms/parameters

#### Artifact
Tangible outputs generated by agents during task processing:
- Documents, images, spreadsheets, structured data
- Composed of one or more Parts
- Can be streamed incrementally

### Interaction Mechanisms

#### Request/Response (Polling)
- Client sends request via `message/send`
- Server responds immediately or with `working` status
- Client polls with `tasks/get` until completion

#### Streaming (Server-Sent Events)
- Client initiates with `message/stream`
- Server maintains open HTTP connection
- Real-time updates via Server-Sent Events
- Supports incremental artifact delivery

#### Push Notifications
- For very long-running tasks
- Client provides webhook URL
- Server sends async notifications via HTTP POST
- Useful when persistent connections are impractical

## Protocol Specification

### Transport and Format

- **Transport**: HTTP(S) only (HTTPS required for production)
- **Payload Format**: JSON-RPC 2.0 for all requests/responses
- **Streaming**: Server-Sent Events (SSE) for real-time updates
- **Content-Type**: `application/json` for JSON-RPC, `text/event-stream` for SSE

### Core RPC Methods

#### 1. `message/send`
Sends a message to initiate or continue a task (synchronous).

**Request**: `MessageSendParams`
**Response**: `Task` or `Message`

#### 2. `message/stream` 
Sends a message and subscribes to real-time updates via SSE.

**Request**: `MessageSendParams`
**Response**: SSE stream of `SendStreamingMessageResponse`

#### 3. `tasks/get`
Retrieves current state of a task.

**Request**: `TaskQueryParams` (task ID, optional history length)
**Response**: `Task` object

#### 4. `tasks/cancel`
Requests cancellation of an ongoing task.

**Request**: `TaskIdParams`
**Response**: `Task` with updated status

#### 5. `tasks/pushNotificationConfig/set`
Configures push notifications for a task.

**Request**: `TaskPushNotificationConfig`
**Response**: Confirmation of configuration

#### 6. `tasks/pushNotificationConfig/get`
Retrieves push notification configuration.

**Request**: `GetTaskPushNotificationConfigParams`
**Response**: `TaskPushNotificationConfig`

#### 7. `tasks/pushNotificationConfig/list`
Lists all push notification configurations for a task.

#### 8. `tasks/pushNotificationConfig/delete`
Deletes a push notification configuration.

#### 9. `tasks/resubscribe`
Reconnects to SSE stream for ongoing task.

#### 10. `agent/authenticatedExtendedCard`
HTTP GET endpoint for authenticated extended Agent Card.

### Authentication & Authorization

**Transport Security:**
- HTTPS with TLS 1.3+ recommended
- Certificate validation against trusted CAs

**Client Authentication:**
1. Discover requirements via Agent Card `authentication` field
2. Obtain credentials out-of-band (OAuth, API keys, etc.)
3. Include credentials in HTTP headers (`Authorization`, `X-API-Key`, etc.)

**Server Responsibilities:**
- Authenticate every request
- Use standard HTTP status codes (401, 403)
- Implement principle of least privilege

## Python SDK Guide

### Installation

**Prerequisites:**
- Python 3.10 or higher
- `uv` (recommended) or `pip`

**Install A2A SDK:**
```bash
# Using uv
uv add a2a-sdk

# Using pip
pip install a2a-sdk
```

**Core Dependencies:**
- `fastapi>=0.115.2`
- `httpx>=0.28.1` 
- `httpx-sse>=0.4.0`
- `pydantic>=2.11.3`
- `grpcio>=1.60`
- `sse-starlette`
- `starlette`

### Client Components

#### A2AClient
Main client class for interacting with A2A servers.

```python
from a2a.client import A2AClient, A2ACardResolver
import httpx

async with httpx.AsyncClient() as httpx_client:
    # Resolve agent card
    resolver = A2ACardResolver(httpx_client, "http://localhost:9999")
    agent_card = await resolver.get_agent_card()
    
    # Initialize client
    client = A2AClient(httpx_client, agent_card=agent_card)
```

#### Key Client Classes
- `A2ACardResolver`: Fetches and validates Agent Cards
- `A2AClient`: Main interface for RPC method calls
- `A2AGrpcClient`: gRPC transport support
- `AuthInterceptor`: Handles authentication middleware
- `CredentialService`: Manages authentication credentials

### Server Components

#### AgentExecutor Interface
Core agent logic implementation:

```python
from a2a.server.agent_execution import AgentExecutor
from a2a.server.agent_execution.context import RequestContext
from a2a.server.events.event_queue import EventQueue

class MyAgentExecutor(AgentExecutor):
    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        # Implement agent logic here
        pass
    
    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        # Handle task cancellation
        pass
```

#### Server Setup
```python
from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore

request_handler = DefaultRequestHandler(
    agent_executor=MyAgentExecutor(),
    task_store=InMemoryTaskStore(),
)

server = A2AStarletteApplication(
    agent_card=agent_card,
    http_handler=request_handler,
)
```

## CLI Implementation

### CLI Client Structure

The A2A samples include a comprehensive CLI client (`hosts/cli`) that demonstrates:

**Core Features:**
- Agent Card discovery and validation
- Interactive message exchange
- File attachment support
- Streaming and push notification handling
- Multi-turn conversation management

**Command Structure:**
```bash
uv run . --agent http://localhost:10000 \
         --session 0 \
         --history false \
         --use_push_notifications false \
         --header "Authorization=Bearer token"
```

**Key Parameters:**
- `--agent`: Target A2A server URL
- `--session`: Session context ID (0 for new)
- `--history`: Include conversation history
- `--use_push_notifications`: Enable async notifications
- `--header`: Custom HTTP headers for authentication

### CLI Implementation Patterns

#### 1. Agent Discovery
```python
card_resolver = A2ACardResolver(httpx_client, agent_url)
card = await card_resolver.get_agent_card()
```

#### 2. Message Construction
```python
message = Message(
    role='user',
    parts=[TextPart(text=user_input)],
    messageId=str(uuid4()),
    taskId=task_id,  # For continuing existing task
    contextId=context_id,
)
```

#### 3. Streaming Response Handling
```python
async for result in client.send_message_streaming(request):
    if isinstance(result.root.result, Task):
        # Handle task updates
    elif isinstance(result.root.result, TaskStatusUpdateEvent):
        # Handle status changes
    elif isinstance(result.root.result, TaskArtifactUpdateEvent):
        # Handle artifact updates
```

#### 4. File Attachment
```python
# Read and encode file
with open(file_path, 'rb') as f:
    file_content = base64.b64encode(f.read()).decode('utf-8')

# Add to message
message.parts.append(
    FilePart(file=FileWithBytes(
        name=os.path.basename(file_path),
        bytes=file_content
    ))
)
```

## Implementation Patterns

### Agent Discovery Workflow

1. **Public Agent Card**: Fetch from `/.well-known/agent.json`
2. **Authentication Check**: Review security requirements
3. **Credential Acquisition**: Obtain tokens/keys out-of-band
4. **Extended Card** (optional): Fetch authenticated extended card
5. **Client Initialization**: Create A2AClient with final card

### Task Lifecycle Management

```python
# 1. Initial message
response = await client.send_message(request)

# 2. Check if task was created
if isinstance(response.result, Task):
    task_id = response.result.id
    
    # 3. Handle input-required state
    if response.result.status.state == TaskState.input_required:
        # Send follow-up message with same task_id
        follow_up = Message(taskId=task_id, ...)
        
    # 4. Poll for completion (if not streaming)
    while response.result.status.state == TaskState.working:
        task = await client.get_task({"id": task_id})
        await asyncio.sleep(1)  # Polling interval
```

### Multi-turn Conversations

**Context Management:**
- Use consistent `contextId` across related tasks
- Include `taskId` in follow-up messages
- Handle `input-required` states appropriately

**Example Pattern:**
```python
context_id = uuid4().hex
task_id = None

while True:
    user_input = input("Enter message: ")
    
    message = Message(
        role='user',
        parts=[TextPart(text=user_input)],
        messageId=str(uuid4()),
        contextId=context_id,
        taskId=task_id,  # None for new, existing for follow-up
    )
    
    response = await client.send_message(request)
    
    if isinstance(response.result, Task):
        task_id = response.result.id
        
        if response.result.status.state == TaskState.input_required:
            continue  # Ask for more input
        elif response.result.status.state == TaskState.completed:
            task_id = None  # Reset for new task
```

## Quick Start Examples

### 1. Hello World Client

```python
import asyncio
import httpx
from uuid import uuid4
from a2a.client import A2AClient, A2ACardResolver
from a2a.types import Message, TextPart, MessageSendParams, SendMessageRequest

async def main():
    async with httpx.AsyncClient() as httpx_client:
        # Get agent card
        resolver = A2ACardResolver(httpx_client, "http://localhost:9999")
        agent_card = await resolver.get_agent_card()
        
        # Create client
        client = A2AClient(httpx_client, agent_card=agent_card)
        
        # Send message
        message = Message(
            role='user',
            parts=[TextPart(text='Hello, world!')],
            messageId=uuid4().hex
        )
        
        request = SendMessageRequest(
            id=str(uuid4()),
            params=MessageSendParams(message=message)
        )
        
        response = await client.send_message(request)
        print(response.model_dump_json(exclude_none=True))

if __name__ == '__main__':
    asyncio.run(main())
```

### 2. Simple CLI Loop

```python
async def cli_loop():
    async with httpx.AsyncClient() as httpx_client:
        resolver = A2ACardResolver(httpx_client, "http://localhost:9999")
        agent_card = await resolver.get_agent_card()
        client = A2AClient(httpx_client, agent_card=agent_card)
        
        context_id = uuid4().hex
        task_id = None
        
        while True:
            user_input = input("\nMessage (or 'quit'): ")
            if user_input.lower() == 'quit':
                break
                
            message = Message(
                role='user',
                parts=[TextPart(text=user_input)],
                messageId=uuid4().hex,
                contextId=context_id,
                taskId=task_id
            )
            
            if agent_card.capabilities.streaming:
                # Use streaming
                async for event in client.send_message_streaming(request):
                    print(f"Event: {event.model_dump_json(exclude_none=True)}")
            else:
                # Use polling
                response = await client.send_message(request)
                print(f"Response: {response.model_dump_json(exclude_none=True)}")
```

### 3. Hello World Server

```python
import uvicorn
from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.types import AgentCard, AgentSkill, AgentCapabilities

# Define agent capabilities
skill = AgentSkill(
    id='hello_world',
    name='Returns hello world',
    description='Just returns hello world',
    tags=['hello world'],
    examples=['hi', 'hello world'],
)

agent_card = AgentCard(
    name='Hello World Agent',
    description='Just a hello world agent',
    url='http://localhost:9999/',
    version='1.0.0',
    defaultInputModes=['text'],
    defaultOutputModes=['text'],
    capabilities=AgentCapabilities(streaming=True),
    skills=[skill],
)

# Create server
request_handler = DefaultRequestHandler(
    agent_executor=HelloWorldAgentExecutor(),
    task_store=InMemoryTaskStore(),
)

server = A2AStarletteApplication(
    agent_card=agent_card,
    http_handler=request_handler,
)

if __name__ == '__main__':
    uvicorn.run(server.build(), host='0.0.0.0', port=9999)
```

## Security Considerations

### Transport Security
- **Always use HTTPS** in production environments
- Use TLS 1.3+ with strong cipher suites
- Validate server certificates against trusted CAs

### Authentication Best Practices
- Never include plaintext secrets in Agent Cards
- Obtain credentials via secure out-of-band processes
- Use dynamic tokens (OAuth, JWTs) over static API keys
- Implement proper credential rotation

### Input Validation
- Validate all RPC parameters rigorously
- Sanitize content in Message and Artifact parts
- Prevent injection attacks through proper escaping
- Validate file attachments for security threats

### Push Notification Security
- Validate webhook URLs to prevent SSRF attacks
- Authenticate server-to-webhook requests
- Verify notification authenticity at receiver
- Use secure token-based validation

### Enterprise Deployment
- Implement rate limiting and concurrency controls
- Use network restrictions and mTLS where appropriate
- Monitor and log all agent interactions
- Follow principle of least privilege for authorization

## Dependencies & Setup

### System Requirements
- **Python**: 3.10 or higher
- **Platform**: Linux, macOS, Windows
- **Memory**: Minimum 512MB available RAM
- **Network**: HTTPS connectivity to agent endpoints

### Python Dependencies (Core SDK)
```toml
dependencies = [
    "fastapi>=0.115.2",
    "httpx>=0.28.1", 
    "httpx-sse>=0.4.0",
    "google-api-core>=1.26.0",
    "opentelemetry-api>=1.33.0",
    "pydantic>=2.11.3",
    "sse-starlette",
    "starlette", 
    "grpcio>=1.60",
    "protobuf==5.29.5",
]
```

### Sample Dependencies (CLI/Examples)
```toml
dependencies = [
    "a2a-sdk>=0.2.9",
    "httpx>=0.28.1",
    "httpx-sse>=0.4.0", 
    "jwcrypto>=1.5.6",
    "pydantic>=2.10.6",
    "pyjwt>=2.10.1",
    "sse-starlette>=2.2.1",
    "uvicorn>=0.34.0",
]
```

### Development Setup

1. **Clone Repository:**
```bash
git clone https://github.com/a2aproject/a2a-samples.git
cd a2a-samples
```

2. **Setup Environment:**
```bash
# Using uv (recommended)
uv sync

# Or using pip
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -r samples/python/requirements.txt
```

3. **Verify Installation:**
```bash
python -c "import a2a; print('A2A SDK imported successfully')"
```

### Environment Variables

**Optional Configuration:**
- `A2A_LOG_LEVEL`: Set logging level (DEBUG, INFO, WARNING, ERROR)
- `A2A_TIMEOUT`: Default HTTP timeout in seconds
- `A2A_MAX_RETRIES`: Maximum retry attempts for failed requests

### Production Deployment

**Server Deployment:**
- Use production WSGI server (gunicorn, uvicorn)
- Configure proper TLS termination
- Set up monitoring and health checks
- Implement proper logging and tracing

**Client Configuration:**
- Configure appropriate timeouts
- Implement retry logic with exponential backoff
- Use connection pooling for efficiency
- Monitor agent discovery and authentication

---

*This documentation covers the Agent2Agent (A2A) Protocol version 0.2.x. For the latest updates and additional resources, visit the [official A2A documentation](https://a2aproject.github.io/A2A/).*